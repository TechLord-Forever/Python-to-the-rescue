# WTFDLL.py

#
# Find libraries loaded at runtime and the functions called
#
# Usage: python WTFDLL.py -p DWRCC.exe [-d P2P.dll] [-a]


from winappdbg import Debug, EventHandler, HexDump, Process, CrashDump
from winappdbg.win32 import *
import sys
import optparse

AUTHOR = "Carlos Garcia Prado <carlos.g.prado@gmail.com>"


# Global vars... Ugly
fd = None
inspect_dll = ""

############################################################################################
def main():

    global fd, inspect_dll     # To modify it
    PROG_INFO = (
             "File automatically generated by %s.\n"
             "%s\n\n"
             % (sys.argv[0], AUTHOR)
             )
    
    ############################################################################
    # Parsing arguments always SUCKS
    parser = optparse.OptionParser()

    parser.add_option('-p', '--program', help = 'Program to inspect', action = 'store', type = 'string', dest = 'prog')    
    parser.add_option('-d', '--dll', help = 'DLL to search for', action = 'store', type = 'string', dest = 'dll')
    parser.add_option('-a', '--all', help = 'Check all DLLs', action = 'store_true', dest = 'all_dlls')
    
            
    (opts, args) = parser.parse_args()
        

    # Mandatory Option (except with '-c')
    if opts.prog is None:
        print "[Error] Check your options!\n"
        parser.print_help()
        sys.exit(1)
    
    if opts.all_dlls:
        program_file = opts.prog
        inspect_dll = ""
    elif opts.dll is not None:
        program_file = opts.prog
        inspect_dll = opts.dll
    else:
        print "[Error] -d and -a are mutually exclusive!\n"
        parser.print_help()
        sys.exit(1)
        
        

    output_filename = 'dll_check.txt'



    fd = open(output_filename, 'w')
    
    '''
    Write some short header. 
    No more open files and thinking "what was this?"
    '''

    fd.write("Analysis of program: %s\n" % program_file)
    fd.write(PROG_INFO)
    
    
    simple_debugger(program_file)
        
    print "[info] Trace finalized."


###########################################################################################
class HitTracerEventHandler(EventHandler):
    ''' Let's hook some API calls '''        
    
    the_flag = 0
    inspect_dll_handler = 0
    
                
    apiHooks = {
        'kernel32.dll': [
                ('LoadLibraryW' ,   1),
                ('GetProcAddress',  2)                 
            ]
        }
        

    # PRE-HOOKS    
    def pre_LoadLibraryW(self, event, ra, pfilename):
        '''
        HMODULE WINAPI LoadLibrary(
          __in  LPCTSTR lpFileName
        );
        '''
        sfilename = event.get_process().peek_string(pfilename, fUnicode = True)
        
        if inspect_dll in sfilename:
            print "LoadLibraryW called with param: %s" % sfilename
            self.the_flag = 1
        else:
            #print "LoadLibraryW called with param: %s" % sfilename
            self.the_flag = 0

        
                
    def pre_GetProcAddress(self, event, ra, hmodule, procname):
        '''
        FARPROC WINAPI GetProcAddress(
          __in  HMODULE hModule,
          __in  LPCSTR lpProcName
        );
        '''
        if hmodule == self.inspect_dll_handler:
            sprocname = event.get_process().peek_string(procname)
            print "\tGetProcAddress called with param: %s" % sprocname
    

    # POST-HOOKS
    def post_LoadLibraryW(self, event, retval):
        if retval:
            # Function succeeded. We have a handler :)
            if self.the_flag == 1:
                # Save the HMODULE to filter the right GetProcAddress calls
                # print "LoadLibraryW succeeded with HMODULE: %s" % hex(retval)
                self.inspect_dll_handler = retval

    
        
############################################################################################    
def simple_debugger(program_file):
    
    process = None
    debug = Debug(HitTracerEventHandler())
    
    
    try:
        # Lookup currently running processes
        debug.system.scan_processes()
        
        for (process, name) in debug.system.find_processes_by_filename(program_file):
            print "[*] Found %d: %s" % (process.get_pid(), name)
            
            # Attach to it
            debug.attach(process.get_pid())
            
        if process == None:
            print "[*] Fatal. Process not found. Is it running?"
            sys.exit(1)
            
        # Wait for all debugees to finish
        debug.loop()
        
    # Cleanup actions
    finally:
        debug.stop()


############################################################################################
def print_logo():
    ''' It prints an old school ascii logo :) '''

    LOGO = (
            "                                                          \n"
            "  __      __  ______  ____    ____    __       __         \n"
            " /\ \  __/\ \/\__  _\/\  _`\ /\  _`\ /\ \     /\ \        \n"
            " \ \ \/\ \ \ \/_/\ \/\ \ \L\_\ \ \/\ \ \ \    \ \ \       \n"
            "  \ \ \ \ \ \ \ \ \ \ \ \  _\/\ \ \ \ \ \ \  __\ \ \  __  \n"
            "   \ \ \_/ \_\ \ \ \ \ \ \ \/  \ \ \_\ \ \ \L\ \\ \ \L\ \ \n"
            "    \ `\___x___/  \ \_\ \ \_\   \ \____/\ \____/ \ \____/ \n"
            "     '\/__//__/    \/_/  \/_/    \/___/  \/___/   \/___/  \n" 
            )
    
    print "%s\n" % LOGO
    print "%s\n\n" % AUTHOR


############################################################################################

if __name__ == "__main__":
    print_logo()
    main()
